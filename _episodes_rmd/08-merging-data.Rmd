---
title: "Merging and Joining Data"
keypoints:
- Use `merge()` to stack data
- Use `merge()` to join data
- Understand joins
objectives:
- Learn how to stack data frames (ex. different years' data)
- Learn how to join - inner, outer, etc.
- Explore after a join to verify results as expected
questions: How can I combine data from different sources?
source: Rmd
teaching: 45
exercises: 10
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("08-")
```

## Combining data from multiple files

Often, the observations of the study participants may be distributed across many different data files.  For example, one file might contain a table with demographics, with one row per participant.  Another file might contain laboratory measurements for some or all of those participants.

To perform your analysis, though, you probably want all of the demographics and laboratory data of interest in a single table which has one row for each participant.

In order to do this, first we'll need to load each of the separate data files into data.frame objects in R.  Once we've done that, we'll be able to use R functions to combine them.

First, let's get the libraries/packages we'll need:


```{r load_libraries, message=FALSE}
library(SASxport)
library(tidyverse)
library(survey) # for using survey weights
# survey::svydesign, svymean, svyglm
library(jtools) # for svycor

```

## A word about packages -- interpreting warnings, masking, and more

Notice that when you ran `library(tidyverse)`, some warnings showed up on the console.  The red Xs might have made you think something went wrong!

Let's break that part of the output down a bit:

TODO: Replace with screenshot or figure out how to colorize text: 
~~~
── Conflicts ────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
~~~

This is telling us that two functions, `filter()` and `log()` from the `dplyr` package **masked** two functions with the same names in the `stats` package, which is always available in R (you don't need to run `install.packages` or `library` to use it).  By **masking**, this means that if you have code that uses the `filter()` function, R is going to give precedence to the package you installed later, and R will assume you meant `filter()` from `dplyr`.

Now what if you still want to use `filter()` from `stats`?  Well, there's a hint in the output above.  You can call it by being more explicit and including the package name, referencing it as `stats::filter()`.

You might also be wondering: But I thought I installed `tidyverse`, not `dplyr`!  Packages can have **dependencies**, meaning that one package needs, or depends on, another.  In this case, `tidyverse` has several dependencies, one of which is `dplyr`, so when you install `tidyverse`, several other packages are installed with it:  `dplyr`, `magrittr`, `ggplot2`, and others.  You definitely _can_ just install the ones you want, instead of the `tidyverse` package which brings all of them in.

```{r, eval=TRUE}

# Demographics data file
demographics <- read.xport('data/DEMO_I.XPT')

# Laboratory data files
bmi_df <- read.xport('data/BMX_I.XPT') 
bp_df <- read.xport('data/BPX_I.XPT')
cbc_df <- read.xport('data/CBC_I.XPT')
glu_df <- read.xport('data/GLU_I.XPT')
tg_df <- read.xport('data/TRIGLY_I.XPT')
hdl_df <- read.xport('data/HDL_I.XPT')
tc_df <- read.xport('data/TCHOL_I.XPT')
# smk_df <- read.xport('data/SMQ_I.XPT')
```

Let's take a quick look at the variables in the demographics file:
```{r}
colnames(demographics)
```

And now let's take a quick look at one of the other files to see which variables are in it:
```{r}
colnames(bmi_df)
```

While it's great that the study measured 25 variables for each participant (idenfied by their SEQN value), we'll end up with a lot of varibles that we don't need for our analysis if we merge the entire table and all of its variables onto our demographics data.  Sometimes you want to keep all of the variables, but many times you only want some.


Now that we have all the files read in, let's merge.



From bmi_df we are keeping: BMXBMI
from bp_df: PBXPLS (pules), BPXSY1 (SBP), PBXDI1 (DPB),
tg_df : LBXTR (triglycerides mg/dL), LBDLDL (LDL mg/dL)
tc_df: LBXTC (total chol mg/dL)
hdl_df: LBDHDD (HDL mg/dL)
cbc_df: LBXWBCSI (WBCs 1000cells/uL)
glu_df: LBXGLU (glucose fasting mg/dL)

HERE WE NEED TO CONSIDER DPLYR FOR JOINING. #TODO

```{r, eval=TRUE}
merge_df <- merge(demographics, bmi_df[ ,c("SEQN", "BMXBMI")])
merge_df <- merge (merge_df, bp_df[ ,c("SEQN", "BPXSY1", "BPXDI1")])
merge_df <- merge(merge_df, tg_df[ , c("SEQN", "LBXTR", "LBDLDL", "WTSAF2YR")])
merge_df <- merge(merge_df, tc_df[ , c("SEQN", "LBXTC")])
merge_df <- merge(merge_df, hdl_df[ , c("SEQN", "LBDHDD")])
merge_df <- merge(merge_df, cbc_df[ , c("SEQN", "LBXWBCSI")])
merge_df <- merge(merge_df, glu_df[ , c("SEQN", "LBXGLU")])
```

```{r, eval=TRUE}
write.csv(merge_df, file = 'data_out/merge.csv', row.names = FALSE)
```

Import the merge_df so we don't have to merge everytime.
```{r, eval=TRUE}
merge_df <- read.csv("data_out/merge.csv")
```

Select variables of interest only.  This also have sampling weight vars.
```{r, eval=TRUE}
merge_df <- merge_df %>% select(SEQN, BMXBMI, RIDAGEYR, BPXSY1, BPXDI1, LBDLDL, LBXTC, LBDHDD, LBXGLU, WTSAF2YR,  SDMVPSU, SDMVSTRA) # WTINT2YR, WTMEC2YR --> not using these 2 weigths.  Instead we are using WTSAF2YR b/c it belongs to the smallest subset.
# see: https://wwwn.cdc.gov/nchs/nhanes/tutorials/module3.aspx
```

Weights: Use "svydesign" to assign the weights
```{r, eval=TRUE}
tg_design <- svydesign(id = ~SDMVPSU,
                      strata = ~SDMVSTRA,
                      weights = ~WTSAF2YR, 
                      nest = TRUE,
                      data = merge_df)
# The svydesign object combines a data frame and all the survey design information needed to analyse it.
# tg for triglycerides
```

# let's subset on age:
```{r, eval=TRUE}
# merge25_df <- merge_df %>% filter((RIDAGEYR>=25 & RIDAGEYR<80)) 
# looks like filter doesn't work once you use svydesign so have to subset.
tg_design2 <- subset(tg_design, RIDAGEYR>=25 & 
                                RIDAGEYR<80) 
```

Variables of interest:
BMI, BP, LDL, TC, HDL, GLU, AGE,
-We are interested in the association between TC and BMI categories. (Total chol (TC) = outcome and glucose (main predictor))

1. After merging, first look at NAs and summaries of variables.
```{r, eval=TRUE}
# Look at descriptive statistics of all independent variables
svymean(~RIDAGEYR, tg_design2, na.rm = TRUE) # RIDAGEYR Mean:49.24 SE:0.6123
summary(tg_design2) # let's not worry about the output from here at the moment. 


# LBXTC is total chol = OUTCOME variable.
# Quantiles/quartiles based on median not mean.
svyquantile(~LBXTC, tg_design2, c(0.25, 0.5, 0.75), ci = TRUE,interval.type = "betaWald", na.rm = TRUE)
svymean(~LBXTC, tg_design2, na.rm = TRUE) # 194.41
svyboxplot(LBXTC~1, tg_design2) # 1 says it's just that one variable. B/c the setup here requies 2 variables otherwise.

#TODO WE NEED TO DO THIS ON ALL THE OTHER VARIABLES OF INTEREST.
sd(merge25_df$LBXTC, na.rm = TRUE) # gives standard deviation; removes na values (na.rm=TRUE)
summary(merge25_df$LBXGLU) # glucose
summary(merge25_df$BMXBMI) # BMI
summary(merge25_df$RIDAGEYR) #TODO exclude people <18yo now. 
```

2. Next, let's look at these variables in detail with graphs:
```{r, eval=TRUE}
#TODO will have to use svyhist
#TODO do a q-q plot to check for normality of IVs.
svyhist(~LBXTC, tg_design2, breaks = 30)

#TODO Convert all of these to svyhist.
hist(merge25_df$LBXTC, breaks = 30, xlab = "Total cholesterol (TC) (mg/dl)",  main = "Distribution of Total Cholesterol") # looks normal
hist(merge25_df$LBXGLU, breaks = 100) # right skewed
boxplot(merge25_df$LBXGLU) # looking at outliers of IV
hist(merge25_df$BMXBMI, breaks = 50) # slightly right skewed
boxplot(merge25_df$BMXBMI) # looking at outliers of IV
hist(merge25_df$RIDAGEYR, breaks = 50) # if you ignore >=80 category and <=10, it's normal looking. 

#TODO Create histograms etc of Blood pressure variables here (for continuous)
```


4.Let's do scatter plots to see linear relationship between predictors and outcome variable:
```{r, eval=TRUE}
svyplot(LBXTC ~ LBXGLU, tg_design2, xlab = "Glucose levels (mg/dl)", ylab = "Total Cholesterol (mg/dl)", main = "TC vs. Glucose")

svyplot(LBXTC ~ BMXBMI, tg_design2, xlab = "BMI", ylab = "Total Cholesterol (mg/dl)", main = "TC vs. BMI")

svyplot(LBXTC ~ LBDLDL, tg_design2, xlab = "LDL", ylab = "Total Cholesterol (mg/dl)", main = "TC vs. LDL")

svyplot(LBXTC ~ LBDHDD, tg_design2, xlab = "HDL", ylab = "Total Cholesterol (mg/dl)", main = "TC vs. HDL")

#TODO: Change all of these to svyplot as above
#TODO: Look at plot.svysmooth
# scatter.smooth(merge25_df$LBXGLU, merge25_df$LBXTC, xlab = "Glucose levels (mg/dl)", ylab = "Total Cholesterol (mg/dl)")
# scatter.smooth(merge25_df$BMXBMI, merge25_df$LBXTC, xlab = "BMI", ylab = "Total Cholesterol (mg/dl)")
# scatter.smooth(merge25_df$RIDAGEYR, merge25_df$LBXTC, xlab = "Age (years)", ylab = "Total Cholesterol (mg/dl)")
# scatter.smooth(merge25_df$LBDHDD, merge25_df$LBXTC, xlab = "HDL", ylab = "Total Cholesterol (mg/dl)")
# scatter.smooth(merge25_df$LBDLDL, merge25_df$LBXTC, xlab = "LDL", ylab = "Total Cholesterol (mg/dl)")
```

5. Let's do a correlation matrix now
```{r, eval=TRUE}

#TODO figure out how to do a correlation matrix. Maybe we can just show it in the non-design weight part and skip it here.
svycor(~ LBXTC + LBXGLU, digits = 2,  design = tg_design2) # everything looks like below 27% multicollinearity.
```



BLOOD PRESSURE CATEGORIES:
https://www.heart.org/-/media/data-import/downloadables/pe-abh-what-is-high-blood-pressure-ucm_300310.pdf

6. Let's create catgegories for variables we are intersted in.
```{r, eval=TRUE}
bp_cat <- function(sbp, dbp) {
 if (is.na(sbp) | is.na(dbp)){
   return(NA)
 }
  #if (sbp>=180 | dbp >=120) {
   # return("Hypertensive Crisis")
  #}
if (sbp>=140 | dbp >=90) {
    return("Hypertension Stage 2+")
  }

if ((sbp>=130 & sbp<=139) | (dbp >=80 & dbp <=89)) {
    return("Hypertension Stage 1")
  }

 if ((sbp>=120 & sbp<=129) &  dbp <80) {
    return("Elevated")
  }

  if (sbp < 120 & dbp <80) {
    return("Normal") 
  }
} 
```  


```{r, eval=TRUE}
# Converting Blood pressure into categories
# merge25_df <- merge25_df %>% mutate(bp_category = bp_cat(BPXSY1, BPXDI1))
merge_df$bp_category <- mapply(bp_cat, merge_df$BPXSY1, merge_df$BPXDI1)
```

Let's first make sure that everything looks okay.  There are over 50 variables, so scrolling through the data frame in the viewer is not a great option.

```{r, eval=TRUE}
# See what the range of text vales is
unique(merge25_df$bp_category)

# Look at just the pertinent columns
just_bp <- merge25_df %>% select(BPXSY1, BPXDI1, bp_category) # check to make sure no NULL values and categories are correctly created

```

```{r, eval=TRUE}
# Converting to factor 
merge25_df$bp_category <- as.factor(merge25_df$bp_category) 
merge25_df$bp_category <- relevel(merge25_df$bp_category, "Normal") #sets "normal" as reference.
str(merge25_df$bp_category)  # Observe that it's a factor
table(merge25_df$bp_category, useNA = "ifany")  # Inspect the values

barplot(table(merge25_df$bp_category)) #TODO reorder so it looks ordinal
```

```{r, eval=TRUE}
# Convert BMI into categories
merge25_df$BMI_category <- cut(merge25_df$BMXBMI, breaks = c(0, 18.5, 25.0, 30.0, 35.0, 40, 100), labels = c("Underweight", "Normal", "Pre-obese", "Obesity I", "Obesity II", "Obesity III"), right = FALSE)

merge25_df$BMI_category <- relevel(merge25_df$BMI_category, "Normal") #this sets "normal" as the reference category.

summary(merge25_df$BMI_category)

```







NOTE: lm ignoes NAs (check this again though).  Make a note of this in the write up of the lesson. 

7. Simple linear regression models:
```{r, eval=TRUE}
#TODO: Set appropriate reference levels in factor variables (for BP and BMI)

# glucose
lm_gluc <- lm(LBXTC ~ LBXGLU, data = merge25_df) 
summary(lm_gluc)

# bmi
lm_bmi <- lm(LBXTC ~ BMXBMI, data = merge25_df)
summary(lm_bmi)

# bmi categorical
lm_bmicat <- lm(LBXTC ~ BMI_category, data = merge25_df)
summary(lm_bmicat)

# age
lm_age <- lm(LBXTC ~ RIDAGEYR, data = merge25_df)
summary(lm_age)

# hdl
lm_hdl <- lm(LBXTC ~ LBDHDD, data = merge25_df)
summary(lm_hdl)

# ldl
lm_ldl <- lm(LBXTC ~ LBDLDL, data = merge25_df)
summary(lm_ldl)

# BP categorical
lm_bp <- lm(LBXTC ~ bp_category, data = merge25_df)
summary(lm_bp)
```

#TODO  INTERACTION TERMS, look at literature to see which ones need to be created. 

Next: Just creating one big model just to see for now.
```{r, eval=TRUE}
lm_model <- lm(LBXTC ~ LBXGLU + BMI_category + LBDHDD + LBDLDL + RIDAGEYR + bp_category, data = merge25_df)
summary(lm_model)
```


